---
sidebar_position: 1
---

# 1장. 리액트 개발을 위해 꼭 알아야 할 자바스크립트 (23.12.02)

- 리액트는 왜 1 depth 까지의 얕은 비교만 수행할까? (shallowEqual)
  - 리액트의 memo는 얕은 비교만 수행한다.
    - 때문에 props에 객체가 들어갈 경우, memo가 정상적으로 작동하지 않는다.
    - 부모 컴포넌트가 리렌더링 될 때 props에 들어가는 객체의 참조가 바뀌기 때문이다.
  - 객체에 대해 깊은 비교를 수행할 경우, 성능상의 이슈가 생긴다.
  - props에 객체같은게 넘어갈 경우, 얕은 비교만 수행하여 제대로 비교가 되지 않고 컴포넌트가 리렌더링 될텐데 이것보다 깊은 비교를 하는 비용이 더 큰지 궁금하다.
    - 얕은 비교 + 객체를 제대로 비교하지 못해서 생기는 리렌더링 + 깊은 비교
    - 어떤게 더 효율적인 방법인지..?
- Object.is 와 shallowEqual
  - Object.is는 같은 값을 가진 객체더라도 참조가 다른 객체에 대해서는 비교하지 못한다.
  - shallowEqual은 참조가 다른 객체이더라도 1 depth 까지는 비교가 가능하다.
- 함수
  - 대부분의 경우 화살표 함수를 사용하지만, 호이스팅의 특성을 살려 가독성이 더 좋다고 생각 될 경우 선언문을 사용할 때도 있다.
- 리액트에서 클래스와 즉시 실행 함수 사용 사례
  - [https://medium.com/@junep/프론트엔드에서-클래스와-즉시-실행-함수-쓰기-315c21bb2493](https://medium.com/@junep/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%EC%97%90%EC%84%9C-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EC%A6%89%EC%8B%9C-%EC%8B%A4%ED%96%89-%ED%95%A8%EC%88%98-%EC%93%B0%EA%B8%B0-315c21bb2493)
- 태스크 큐, 마이크로 태스크 큐, 렌더링
  - 동기 → 마이크로 태스크 큐(Promise, …) → 렌더링 → 태스크 큐(setTimeout, … ) 순으로 실행된다.
  - 이 때문에 동기 코드와 마이크로 태스크 큐에서 오래 걸리는 작업이 실행 될 경우 렌더링에도 영향을 끼친다.
  - 태스크 큐로 분리할 수 있는 작업은 상황에 맞게 분리하는 것이 좋다.
- 클로저
  - 리액트의 useState는 클로저로 구현되어 있다.
  - 클로저는 내부 상태를 기억하기 위해 메모리를 사용하므로 성능 상의 문제가 생길 수 있다.
